/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package Vistas;

import Modelos.*;
import java.awt.Color;
import java.awt.Graphics;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.LinkedList;

/**
 *
 * @author Jorge Alejandro
 */
public class PanelAutomata extends javax.swing.JPanel implements Runnable {

    String ejecucion;
    LinkedList<String> espera;
    LinkedList<String> bloqueo;
    ArrayList<String> fin;
    int cuenta;

    /**
     * Creates new form PanelAutomata
     */
    public PanelAutomata() {
        initComponents();
        ejecucion = null;
        espera = new LinkedList();
        bloqueo = new LinkedList();
        fin = new ArrayList();
        cuenta = 0;
    }

    @Override
    public void paint(Graphics g) {
        super.paint(g);
        if (FrameMenu.controladora != null) {
            int diametro = 80;
            g.setColor(Color.white);
            g.fillOval(0, 130, diametro, diametro);
            g.fillOval(350, 10, diametro, diametro);
            g.setColor(Color.blue);
            g.fillOval(120, 130, diametro, diametro);
            g.setColor(Color.yellow);
            g.fillOval(220, 40, diametro, diametro);
            g.setColor(Color.red);
            g.fillOval(350, 130, diametro, diametro);
            g.setColor(Color.BLACK);
            g.drawString("El tiempo de ejecución terminará en: " + cuenta + " seg", 0, 23);

            g.drawOval(0, 130, diametro, diametro);
            g.drawString(FrameMenu.controladora.getAutomata().getInicio(), 30, 130);

            int inicio_listo[] = FrameMenu.controladora.getAutomata().getInicio_listo();
            g.drawLine(inicio_listo[0], inicio_listo[1], inicio_listo[2], inicio_listo[3]); //Flecha entre inicio y espera

            g.drawOval(120, 130, diametro, diametro);
            g.drawString(FrameMenu.controladora.getAutomata().getListo(), 150, 130);

            int listo_ejecucion[] = FrameMenu.controladora.getAutomata().getListo_ejecucion();
            g.drawLine(listo_ejecucion[0], listo_ejecucion[1], listo_ejecucion[2], listo_ejecucion[3]); //Flecha entre espera y ejecucion

            g.drawOval(220, 40, diametro, diametro);
            g.drawString(FrameMenu.controladora.getAutomata().getEjecucion(), 250, 40);

            int ejecucion_bloqueo[] = FrameMenu.controladora.getAutomata().getEjecucion_bloqueo();
            g.drawLine(ejecucion_bloqueo[0], ejecucion_bloqueo[1], ejecucion_bloqueo[2], ejecucion_bloqueo[3]); //Flecha entre Ejecucion y bloqueo

            g.drawOval(350, 130, diametro, diametro);
            g.drawString(FrameMenu.controladora.getAutomata().getBloqueo(), 380, 130);

            int listo_bloqueo[] = FrameMenu.controladora.getAutomata().getListo_bloqueo();
            g.drawLine(listo_bloqueo[0], listo_bloqueo[1], listo_bloqueo[2], listo_bloqueo[3]); //Flecha entre Listo Bloqueo

            g.drawOval(350, 10, diametro, diametro);
            g.drawString(FrameMenu.controladora.getAutomata().getFin(), 380, 10);

            int ejecucion_fin[] = FrameMenu.controladora.getAutomata().getEjecucion_fin();
            g.drawLine(ejecucion_fin[0], ejecucion_fin[1], ejecucion_fin[2], ejecucion_fin[3]); //Flecha entre Ejecucion y fin

            pintarListas(g);

        }
        repaint();
    }

    private void pintarListas(Graphics g) {
        g.setColor(Color.BLACK);
        for (int i = 0; i < this.espera.size(); i++) {
            g.drawString(espera.get(i), 150, 150 + (i * 10));
        }

        for (int i = 0; i < this.bloqueo.size(); i++) {
            g.drawString(bloqueo.get(i), 380, 150 + (i * 10));
        }

        for (int i = 0; i < this.fin.size(); i++) {
            g.drawString(fin.get(i), 380, 30 + (i * 10));
        }

        if (ejecucion != null) {
            g.drawString(ejecucion, 250, 60);
        }

    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    @Override
    public void run() {
        cambiardeEstados();
    }

    private void cambiardeEstados() {
        String temporal=null;
        for (int i = 0; i < FrameMenu.controladora.getCiclos().size(); i++) {
            cuenta =FrameMenu.controladora.getQuantum();
            for (int j = 0; j < FrameMenu.controladora.getCiclos().get(i).getPintar().size(); j++) {
                switch (FrameMenu.controladora.getCiclos().get(i).getPintar().get(j).getTipo()) {
                    case "bloqueo":
                        bloqueo.add(FrameMenu.controladora.getCiclos().get(i).getPintar().get(j).getProceso());
                        break;
                    case "ejecucion":
                        this.ejecucion = FrameMenu.controladora.getCiclos().get(i).getPintar().get(j).getProceso();
                        break;
                    case "espera":
                        espera.add(FrameMenu.controladora.getCiclos().get(i).getPintar().get(j).getProceso());
                        break;
                }
                if(FrameMenu.controladora.getCiclos().get(i).getPintar().get(j).getQuantum()==-1)
                {
                    for(int k=0; k<FrameMenu.controladora.getCiclos().get(i).getPintar().get(j).getAuxiliar(); k++)
                    {
                        cuenta=cuenta-1;
                        esperar(1);
                    }
                    bloqueo.remove(FrameMenu.controladora.getCiclos().get(i).getPintar().get(j).getProceso());
                }
                if(FrameMenu.controladora.getCiclos().get(i).getPintar().get(j).getDuracionejecucion()==FrameMenu.controladora.getCiclos().get(i).getPintar().get(j).getTiempoejecucion())
                {
                    temporal=FrameMenu.controladora.getCiclos().get(i).getPintar().get(j).getProceso();
                }
            }
            for (int k = cuenta; k > 0; k--) {
                cuenta--;
                esperar(1);
            }
            if(temporal!=null)
            {
                fin.add(temporal);
                temporal=null;
            }
            espera=new LinkedList<>();
            bloqueo=new LinkedList<>();
            ejecucion=null;
            
        }
    }

    private void esperar(int tiempo) {
        try {
            Thread.sleep(tiempo * 1000);
        } catch (InterruptedException ex) {
            System.out.println(ex.getMessage());
        }
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
