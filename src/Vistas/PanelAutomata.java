/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package Vistas;

import Modelos.*;
import java.awt.Color;
import java.awt.Graphics;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 *
 * @author Jorge Alejandro
 */
public class PanelAutomata extends javax.swing.JPanel implements Runnable {

    String ejecucion;
    String inicio;
    LinkedList<String> procesos;
    LinkedList<String> listo;
    LinkedList<String> bloqueo;
    ArrayList<Proceso> fin;
    ArrayList<Grafico> ciclos;
    int cuenta;
    String bloquear;

    /**
     * Creates new form PanelAutomata
     */

    public PanelAutomata() {
        initComponents();
        ejecucion = null;
        listo = new LinkedList();
        bloqueo = new LinkedList();
        fin = new ArrayList();
        ciclos = FrameMenu.controladora.getCiclos();
        cuenta = FrameMenu.controladora.getQuantum();
        bloquear = "";
    }

    @Override
    public void paint(Graphics g) {
        super.paint(g);
        if (FrameMenu.controladora != null) {
            int diametro = 80;
            g.setColor(Color.white);
            g.fillOval(0, 130, diametro, diametro);
            g.fillOval(350, 10, diametro, diametro);
            g.setColor(Color.blue);
            g.fillOval(120, 130, diametro, diametro);
            g.setColor(Color.yellow);
            g.fillOval(220, 40, diametro, diametro);
            g.setColor(Color.red);
            g.fillOval(350, 130, diametro, diametro);

            g.setColor(Color.red);
            g.drawString(bloquear, 0, 10);
            g.setColor(Color.BLACK);
            g.drawString("El tiempo de ejecución terminará en: " + cuenta + " seg", 0, 23);

            g.drawOval(0, 130, diametro, diametro);
            g.drawString(FrameMenu.controladora.getAutomata().getInicio(), 30, 130);

            int inicio_listo[] = FrameMenu.controladora.getAutomata().getInicio_listo();
            g.drawLine(inicio_listo[0], inicio_listo[1], inicio_listo[2], inicio_listo[3]); //Flecha entre inicio y listo

            g.drawOval(120, 130, diametro, diametro);
            g.drawString(FrameMenu.controladora.getAutomata().getListo(), 150, 130);

            int listo_ejecucion[] = FrameMenu.controladora.getAutomata().getListo_ejecucion();
            g.drawLine(listo_ejecucion[0], listo_ejecucion[1], listo_ejecucion[2], listo_ejecucion[3]); //Flecha entre listo y ejecucion

            g.drawOval(220, 40, diametro, diametro);
            g.drawString(FrameMenu.controladora.getAutomata().getEjecucion(), 250, 40);

            int ejecucion_bloqueo[] = FrameMenu.controladora.getAutomata().getEjecucion_bloqueo();
            g.drawLine(ejecucion_bloqueo[0], ejecucion_bloqueo[1], ejecucion_bloqueo[2], ejecucion_bloqueo[3]); //Flecha entre Ejecucion y bloqueo

            g.drawOval(350, 130, diametro, diametro);
            g.drawString(FrameMenu.controladora.getAutomata().getBloqueo(), 380, 130);

            int listo_bloqueo[] = FrameMenu.controladora.getAutomata().getListo_bloqueo();
            g.drawLine(listo_bloqueo[0], listo_bloqueo[1], listo_bloqueo[2], listo_bloqueo[3]); //Flecha entre Listo Bloqueo

            g.drawOval(350, 10, diametro, diametro);
            g.drawString(FrameMenu.controladora.getAutomata().getFin(), 380, 10);

            int ejecucion_fin[] = FrameMenu.controladora.getAutomata().getEjecucion_fin();
            g.drawLine(ejecucion_fin[0], ejecucion_fin[1], ejecucion_fin[2], ejecucion_fin[3]); //Flecha entre Ejecucion y fin

            pintarListas(g);

        }
        repaint();
    }

    private void pintarListas(Graphics g) {
        g.setColor(Color.BLACK);
        for (int i = 0; i < this.listo.size(); i++) {
            g.drawString(listo.get(i), 150, 150 + (i * 10));
        }

        for (int i = 0; i < this.bloqueo.size(); i++) {
            g.drawString(listo.get(i), 380, 150 + (i * 10));
        }

        for (int i = 0; i < this.fin.size(); i++) {
            g.drawString(fin.get(i).getNombre(), 380, 30 + (i * 10));
        }

        if (ejecucion != null) {
            g.drawString(ejecucion, 250, 60);
        }

    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    @Override
    public void run() {
        int tiempo = 0;
        int quantum = FrameMenu.controladora.getQuantum();
        int cantidad = FrameMenu.controladora.Procesos().size();
        int tiempos[] = new int[cantidad];
        Iterator<Grafico> ciclo = ciclos.iterator();

        while (fin.size() < cantidad) {

//verificarNuevos(tiempo);
//            verificarBloqueados(tiempo);
//            if(ejecucion!=null)
//            {
//                if(ejecucion.getBloqueoinicial()==tiempo)
//                {   
//                    bloqueo.add(ejecucion);
//                    tiempos[FrameMenu.controladora.Procesos().indexOf(ejecucion)]+=(quantum-cuenta);
//                    ejecucion=listo.poll();
//                    cuenta=quantum;
//                }                
//            }
            if (cuenta == 0) {
                cuenta = quantum;
            }

            if (cuenta == quantum) {
                if (ejecucion != null) {
                    tiempos[FrameMenu.controladora.Procesos().indexOf(ejecucion)] += quantum;
                    
                }
//                ejecucion=listo.poll();
                if (ciclo.hasNext()) {
                    cambiardeEstados(ciclo.next(), tiempos);
                }
            }
            //AgregarBloqueo(tiempo,tiempos);
            tiempo++;
            cuenta--;
            esperar(1);
        }
        ejecucion = null;
    }

    private void cambiardeEstados(Grafico ciclo, int[] tiempos) {
//        for(PintarQuantumGrafico iteracion:ciclo.getPintar())        
//        {
//            switch (iteracion.getTipo()) {
//                case "bloqueo":
//                    bloqueo.add(buscar(iteracion.getProceso()));
//                    tiempos[FrameMenu.controladora.Procesos().indexOf(buscar(iteracion.getProceso()))]+=(FrameMenu.controladora.getQuantum()-cuenta);
//                    cuenta=FrameMenu.controladora.getQuantum();
//                    listo.remove(buscar(iteracion.getProceso())); 
//                    bloquear="bloqueo, bloqueo, bloqueo!!!";
//                    esperar(3);
//                    bloquear="";
//                    break;
//                case "ejecucion":
//                    if(ejecucion!=null)
//                        if(!this.bloqueo.contains(ejecucion)&&!this.fin.contains(ejecucion))
//                            this.listo.add(ejecucion);
//                    this.ejecucion=buscar(iteracion.getProceso());
//                    this.listo.remove(ejecucion);
//                    break;
//                case "espera":
//                    //si no funciona poner esta validacion en el else if de arriba
//                    Proceso p=buscar(iteracion.getProceso());
//                    this.bloqueo.remove(p);
//                    if(!listo.contains(p))
//                        this.listo.add(p);
//                    break;                
//                default:
//                    break;
//            }
//        }

        for (int i = 0; i < FrameMenu.controladora.getCiclos().size(); i++) {
            for (int j = 0; j<FrameMenu.controladora.getCiclos().get(i).getPintar().size(); j++) {
                switch (FrameMenu.controladora.getCiclos().get(i).getPintar().get(j).getTipo()) {
                    
                    case "bloqueo":
                        bloqueo.add(FrameMenu.controladora.getCiclos().get(i).getPintar().get(j).getProceso());
                        //tiempos[FrameMenu.controladora.Procesos().indexOf(p)] += (FrameMenu.controladora.getQuantum() - cuenta);
                        cuenta = FrameMenu.controladora.getQuantum();
                        listo.remove(FrameMenu.controladora.getCiclos().get(i).getPintar().get(j).getProceso());
                        bloquear = "bloqueo, bloqueo, bloqueo!!!";
                        esperar(3);
                        bloquear = "";
                        break;
                    case "ejecucion":
                        this.listo.add(ejecucion);                                                    
                        this.ejecucion = FrameMenu.controladora.getCiclos().get(i).getPintar().get(j).getProceso();
                        this.listo.remove(ejecucion);
                        
                        break;
                    case "espera":
                        this.bloqueo.remove(FrameMenu.controladora.getCiclos().get(i).getPintar().get(j).getProceso());
                        if (!listo.contains(FrameMenu.controladora.getCiclos().get(i).getPintar().get(j).getProceso())) {
                            this.listo.add(FrameMenu.controladora.getCiclos().get(i).getPintar().get(j).getProceso());
                        }
                        break;
                    default:
                        break;
                }
            }
            
        }
        fin=FramePrincipal.rr;
        //Bloqueo_Listo(ciclo);
    }

    private void AgregarBloqueo(int tiempo, int[] tiempos) {
        for (Proceso proceso : FrameMenu.controladora.Procesos()) {
            if (proceso.getBloqueoinicial() == tiempo && tiempo > 0) {
//                bloqueo.add(proceso);

//                if(ejecucion!=proceso)
//                {
//                    this.listo.add(ejecucion);
//                    ejecucion=proceso;
//                    
//                    //ejecucion=listo.poll();
//                    
//                }
            }
        }
    }

    private void Bloqueo_Listo(Grafico ciclo) {
        for (PintarQuantumGrafico iteracion : ciclo.getPintar()) {
        }
    }

    private Proceso buscar(String nombre) {
        for (Proceso x : FrameMenu.controladora.Procesos()) {
            if (x.getNombre().equals(nombre)) {
                return x;
            }
        }
        return null;
    }

//    private void verificarNuevos(int tiempo) {
//        for (int i = 0; i < procesos.size(); i++) {
//            if (procesos.get(i).getLlegada() == tiempo) {
//                listo.add(procesos.remove(i));
//            }
//        }
//    }

    private void esperar(int tiempo) {
        try {
            Thread.sleep(tiempo * 1000);
        } catch (InterruptedException ex) {
            Logger.getLogger(PanelAutomata.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

//    private void verificarBloqueados(int tiempo) {
//        for (int i = 0; i < bloqueo.size(); i++) {
//            if (bloqueo.get(i).getBloqueofinal() > 0) {
//                if (bloqueo.get(i).getBloqueofinal() == tiempo) {
//                    listo.add(bloqueo.remove(i));
//                }
//            }
//        }
//    }

    private boolean verificarFin(int tiempos[],Proceso proceso) {
        if (tiempos[FrameMenu.controladora.Procesos().indexOf(proceso)] >= proceso.getDuracion()) {
            return fin.add(proceso);
        }
        return false;
    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
